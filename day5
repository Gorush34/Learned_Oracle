    ----------------------------------------------------------------------------------------------------------------------------------
    
    -- *** 요약값을 보여주는 rollup, cube, grouping sets, groupin 에 대해서 알아보자. ---
            ----- >>>>> 요약값(rollup, cube, grouping sets) <<<<< ------
  /*
      1. rollup(a,b,c) 은 grouping sets( (a,b,c),(a,b),(a),() ) 와 같다.
    
         group by rollup(department_id, gender) 은
         group by grouping sets( (department_id, gender), (department_id), () ) 와 같다.
  
      2. cube(a,b,c) 은 grouping sets( (a,b,c),(a,b),(b,c),(a,c),(a),(b),(c),() ) 와 같다.
 
         group by cube(department_id, gender) 은
         group by grouping sets( (department_id, gender), (department_id), (gender), () ) 와 같다.
         
         => rollup은 모두를 보여준 뒤 가장 마지막 요소부터 빼고 보여줌.
         => cube는 모든 경우의 수를 다 보여줌.
         => grouping set 는 내가 보고싶은 것만 볼 수 있음.
  */
    -- employees 테이블에서 부서번호별로 인원수를 나타내면서 동시에 전체인원수도 나타내세요. ---
    
    select department_id
         , count(*)
    from employees
    group by rollup(department_id);
    -- rollup(a) => a값이 일치하는 대상들을 묶어준다. 맨 밑의 null은 전체인원수.
    
    
    select department_id
         , grouping(department_id) 
         -- grouping(department_id) 은 결과값이 오로지 2개(0, 1)만 나온다. 
         -- 0은 department_id 컬럼의 값으로 그룹을 지었다는 뜻이고 1이라 함은 그룹을 안지었다는 말이다.
         , count(*)
    from employees
    group by rollup(department_id);
    
    
    
    select decode( grouping(department_id), '0', nvl( to_char(department_id), '인턴')
                                               , '전체') AS 부서번호
         , count(*)
    from employees
    group by rollup(department_id);
    -- 부서번호별로 rollup
    
    select decode( grouping(department_id), '0', nvl( to_char(department_id), '인턴')
                                               , '전체') AS 부서번호
         , count(*)
         , round( (count(*) / (select count(*) from employees) * 100), 1) AS 퍼센티지
    from employees
    group by rollup(department_id);
    -- 부서별 인원을 전체인원의 퍼센티지로 나타냄.
    
    
    
        -- employees 테이블에서 부서번호별, 성별로 인원수를 나타내면서 동시에 전체인원수도 나타내세요. ---
    /*
    ------------------------------
    부서번호    성별  인원수 퍼센티지
    ------------------------------   
      10        남    1
      10        여    1
      10        전체   2
      20        남    2
      20        여    2
      20        전체   4
                ...
      전체      남
                여
    
    */
    -- 문자열에서 ''은 null이고 ' ' 은 공백이다. 명백히 다륾!!!
    -- rollup 사용시 --
    
    select decode( grouping(V.department_id), 0, nvl(to_char(V.department_id), '부서없음'), 1, '전체') AS 부서번호
         , decode( grouping(V.GENDER), 0, V.GENDER, 1, '전체' ) AS 성별
         , count(*) AS 인원수
         , round( count(*) / (select count(*) from employees) * 100 , 1) AS 퍼센티지

    from
    (
    select department_id
         , case when substr(jubun, 7, 1) in ('1', '3') then '남' else '여' end AS GENDER
    from employees
    ) V
    group by rollup(v.department_id, V.GENDER);
    ---------------------------------------
    --- grouping sets 사용시 ---
        select decode( grouping(V.department_id), 0, nvl(to_char(V.department_id), '부서없음'), 1, '전체') AS 부서번호
         , decode( grouping(V.GENDER), 0, V.GENDER, 1, '전체' ) AS 성별
         , count(*) AS 인원수
         , round( count(*) / (select count(*) from employees) * 100 , 1) AS 퍼센티지

    from
    (
    select department_id
         , case when substr(jubun, 7, 1) in ('1', '3') then '남' else '여' end AS GENDER
    from employees
    ) V
    group by grouping sets((V.department_id, V.GENDER), V.department_id, ());
    
    
    ----------------------------------------------------------------------------------------------------------------------
    --- cube 사용시 ---
    select decode( grouping(V.department_id), 0, nvl(to_char(V.department_id), '부서없음'), 1, '전체') AS 부서번호
         , decode( grouping(V.GENDER), 0, V.GENDER, 1, '전체' ) AS 성별
         , count(*) AS 인원수
         , round( count(*) / (select count(*) from employees) * 100 , 1) AS 퍼센티지

    from
    (
    select department_id
         , case when substr(jubun, 7, 1) in ('1', '3') then '남' else '여' end AS GENDER
    from employees
    ) V
    group by cube(v.department_id, V.GENDER)
    -- order by 1; 이걸로 하면 부서번호로 정렬이기때문에 부서번호는 문자 ==> 10, 100, 110, 20 순으로 정렬됨.
    order by V.department_id;
    
    
    --- grouping sets 사용시 ---
    select decode( grouping(V.department_id), 0, nvl(to_char(V.department_id), '부서없음'), 1, '전체') AS 부서번호
         , decode( grouping(V.GENDER), 0, V.GENDER, 1, '전체' ) AS 성별
         , count(*) AS 인원수
         , round( count(*) / (select count(*) from employees) * 100 , 1) AS 퍼센티지

    from
    (
    select department_id
         , case when substr(jubun, 7, 1) in ('1', '3') then '남' else '여' end AS GENDER
    from employees
    ) V
    group by grouping sets( (v.department_id, V.GENDER), v.department_id, V.GENDER, () )
    order by V.department_id;
        
    -- grouping sets 에서 요소를 빼보자.
    select decode( grouping(V.department_id), 0, nvl(to_char(V.department_id), '부서없음'), 1, '전체') AS 부서번호
         , decode( grouping(V.GENDER), 0, V.GENDER, 1, '전체' ) AS 성별
         , count(*) AS 인원수
         , round( count(*) / (select count(*) from employees) * 100 , 1) AS 퍼센티지

    from
    (
    select department_id
         , case when substr(jubun, 7, 1) in ('1', '3') then '남' else '여' end AS GENDER
    from employees
    ) V
    group by grouping sets( (v.department_id, V.GENDER), V.GENDER, () )
    order by V.department_id;
    
    ---------- ======= ****   having 그룹함수조건절   **** ======= ----------
   /*
       group by 절을 사용하여 그룹함수의 값을 나타내었을때
       그룹함수의 값이 특정 조건에 해당하는 것만 추출하고자 할때는 where 절을 사용하는 것이 아니라
       having 그룹함수조건절 을 사용해야 한다.
   */
   
   -- employees 테이블에서 사원이 10명 이상 근무하는 부서번호와 그 인원수를 나타내세요.
   
    select department_id, count(*)
    from employees
    where count(*) >= 10
    group by department_id;  -- 오류 
    
    select department_id AS 부서번호
         , count(*) AS 인원수
    from employees
    group by department_id
    having count(*) >= 10
    order by 2 desc;
    
    
        --- [퀴즈] employees 테이블에서 부서번호별로 월급의 합계를 나타내었을 때
   --        부서번호별 월급의 합계가 50000 이상인 부서에 대해서만
   --        부서번호, 월급의 합계를 나타내세요.
   
   select department_id AS 부서번호
        , to_char( sum(nvl( salary + (salary * commission_pct), salary) )
                   , '999,999') AS 월급
   from employees
   group by department_id
   having  sum(nvl( salary + (salary * commission_pct), salary) ) >= 50000
   order by 2 desc;
   
   
   ------- **** !!! 누적(누계)에 대해서 알아봅니다. !!! **** ---------
   /*
        sum(누적되어야할 컬럼명) over(order by 누적되어질 기준이 되는 컬럼명 asc[desc] )
        
        sum(누적되어야할 컬럼명) over(partition by 그룹화 되어질 컬럼명 
                                   order by 누적되어질 기준이 되는 컬럼명 asc[desc] )
   */
   
   create table tbl_panmae
     (panmaedate  date
     ,jepumname   varchar2(20)
     ,panmaesu    number
     );
   -- Table TBL_PANMAE이(가) 생성되었습니다.
   
     -- 명령어 한 문단씩만 실행할 것!!!!!!!!!
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( add_months(sysdate,-2), '새우깡', 10);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( add_months(sysdate,-2)+1, '새우깡', 15); 
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( add_months(sysdate,-2)+2, '감자깡', 20);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( add_months(sysdate,-2)+3, '새우깡', 10);
     
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( add_months(sysdate,-2)+3, '새우깡', 3);
     
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( add_months(sysdate,-1), '고구마깡', 7);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( add_months(sysdate,-1)+1, '새우깡', 8); 
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( add_months(sysdate,-1)+2, '감자깡', 10);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( add_months(sysdate,-1)+3, '감자깡', 5);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( sysdate - 4, '허니버터칩', 30);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( sysdate - 3, '고구마깡', 15);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( sysdate - 2, '고구마깡', 10);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( sysdate - 1, '허니버터칩', 20);
    
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( sysdate, '새우깡', 10);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( sysdate, '새우깡', 10);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( sysdate, '감자깡', 5);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( sysdate, '허니버터칩', 15);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( sysdate, '고구마깡', 20);
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( sysdate, '감자깡', 10); 
    
     insert into tbl_panmae(panmaedate, jepumname, panmaesu)
     values( sysdate, '새우깡', 10);
    
     commit;
     
     select *
     from tbl_panmae;
     
     
    -- *** tbl_panmae 테이블에서 '새우깡' 에 대한 일별 판매량과 일별누적판매량을 나타내세요.
     
    select to_char(panmaedate, 'yyyy-mm-dd hh24:mi:ss') AS panmaedate, panmaesu
    from tbl_panmae
    where jepumname = '새우깡';
    
    
    ----------------------------------------------------------
    판매일자            일별판매량       일별누적판매량
    ----------------------------------------------------------
    2021-11-10	        10              10
    2021-11-11	        15              25
    2021-11-13	        13              38
    2021-12-11	        8               46
    2022-01-10	        30              76
    -----------------------------------------------------------
    
    
    select to_char(panmaedate, 'yyyy-mm-dd') AS 판매일자
         , sum(panmaesu) AS 일별판매량
         -- , sum(누적되어야할 컬럼명) over(order by 누적되어질 기준이 되는 컬럼명 asc[desc] )
         , sum( sum(panmaesu) ) over(order by to_char(panmaedate, 'yyyy-mm-dd') asc) AS 일별누적판매량
    from tbl_panmae
    where jepumname = '새우깡'
    group by to_char(panmaedate, 'yyyy-mm-dd');
    
    
    -- *** tbl_panmae 테이블에서 모든 제품 에 대한 일별 판매량과 일별누적판매량을 나타내세요.
    ----------------------------------------------------------
    제품명     판매일자            일별판매량       일별누적판매량
    ----------------------------------------------------------
    새우깡     2021-11-10	            10              10
              2021-11-11	        15              25
              2021-11-13	        13              38
              2021-12-11	        8               46
              2022-01-10	        30              76
    감자깡     2021-11-12	            20	            20
              2021-12-12	        10	            30
              2021-12-13	        5	            35
              2022-01-10	        15	            50
    -----------------------------------------------------------
    

    
    
